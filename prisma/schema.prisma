generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String   @id @default(cuid())
  firstName              String?
  lastName               String?
  email                  String   @unique
  imageUrl               String?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  
  // Profile information
  bio                    String?
  location               String?
  
  // Privacy settings
  isPublic               Boolean  @default(true)
  showStats              Boolean  @default(true)
  showActivity           Boolean  @default(true)
  allowMentions          Boolean  @default(true)
  showLocation           Boolean  @default(false)
  
  // Location settings
  defaultLocation        String?
  autoDetectLocation     Boolean  @default(false)
  
  // Notification preferences stored as JSON
  notificationPreferences String?  // JSON string of NotificationPreferencesData
  
  // Relationships
  campaigns         Campaign[]
  votes             Vote[]
  comments          Comment[]
  pushSubscriptions PushSubscription[]
  wonders           Wonder[]           // Wonders created by user
  wonderResponses   WonderResponse[]   // Wonder responses by user

  // Performance indexes for user queries
  @@index([createdAt])
  @@index([updatedAt])
  @@index([firstName, lastName])
  @@index([location])
  @@index([isPublic])
  @@map("users")
}

model Campaign {
  id          String        @id @default(cuid())
  title       String
  description String
  status      CampaignStatus @default(DRAFT)
  
  // Location data
  latitude    Float?
  longitude   Float?
  address     String?
  city        String?
  state       String?
  zipCode     String?
  geohash     String?
  
  // Media
  imageUrl    String?
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  creatorId   String
  
  // Relationships
  creator     User       @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  votes       Vote[]
  comments    Comment[]
  districts   CampaignDistrict[]
  fromWonder  Wonder[]        // If originated from a wonder
  fromPattern WonderPattern[] // If originated from a pattern

  // Performance-optimized indexes for common queries
  @@index([status, createdAt])
  @@index([creatorId, status])
  @@index([city, status])
  @@index([state, city, status])
  @@index([geohash])
  @@index([title])
  @@index([latitude, longitude])
  @@index([createdAt])
  @@index([updatedAt])
  @@map("campaigns")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relationships
  campaignId String
  authorId   String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  author     User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Performance indexes for comment queries
  @@index([campaignId, createdAt])
  @@index([authorId, createdAt])
  @@index([createdAt])
  @@map("comments")
}

model Vote {
  id         String   @id @default(cuid())
  type       VoteType
  createdAt  DateTime @default(now())
  
  // Relationships
  campaignId String
  userId     String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([campaignId, userId])
  // Performance indexes for vote aggregation and analysis
  @@index([campaignId, type])
  @@index([userId, createdAt])
  @@index([type, createdAt])
  @@index([createdAt])
  @@map("votes")
}

model District {
  id       String   @id @default(cuid())
  name     String
  type     DistrictType
  state    String?
  
  // Geographic data
  boundary Json?    // GeoJSON polygon
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relationships
  campaigns CampaignDistrict[]

  // Performance indexes for district queries
  @@index([state, type])
  @@index([type])
  @@map("districts")
}

model CampaignDistrict {
  id         String   @id @default(cuid())
  campaignId String
  districtId String
  
  // Relationships
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  district   District @relation(fields: [districtId], references: [id], onDelete: Cascade)
  
  @@unique([campaignId, districtId])
  // Performance indexes for campaign-district relationships
  @@index([campaignId])
  @@index([districtId])
  @@map("campaign_districts")
}

model PushSubscription {
  id               String   @id @default(cuid())
  userId           String
  endpoint         String
  p256dh           String?
  auth             String?
  userAgent        String?
  subscriptionData String?  // JSON string of full subscription object
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  lastUpdated      DateTime @updatedAt
  
  // Relationships
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, endpoint])
  @@index([userId])
  @@index([isActive])
  @@index([createdAt])
}

model Wonder {
  id               String           @id @default(cuid())
  question         String
  category         WonderCategory   @default(GENERAL)
  authorId         String?
  
  // Context data
  locationContext  String?          // e.g., "commute", "neighborhood"
  timeContext      WonderTimeContext @default(ANYTIME)
  
  // Aggregation data
  responseCount    Int              @default(0)
  patternDetected  Boolean          @default(false)
  campaignId       String?          // If evolved into campaign
  
  // Status
  status           WonderStatus     @default(ACTIVE)
  isSeeded         Boolean          @default(false) // System-generated vs user-generated
  
  // Metadata
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  
  // Relationships
  author           User?            @relation(fields: [authorId], references: [id], onDelete: SetNull)
  responses        WonderResponse[]
  patterns         WonderPattern[]
  campaign         Campaign?        @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  
  // Performance indexes
  @@index([status, createdAt])
  @@index([category, status])
  @@index([timeContext, status])
  @@index([responseCount])
  @@index([patternDetected])
  @@index([authorId])
  @@map("wonders")
}

model WonderResponse {
  id                String    @id @default(cuid())
  wonderId          String
  userId            String
  
  // Audio and text content
  audioUrl          String?   // Uploadthing URL
  transcription     String?   // AI transcription
  textResponse      String?   // Direct text input (fallback)
  
  // AI-extracted data
  parsedLocation    String?   // Extracted location mentions
  parsedNeed        String?   // Extracted need/desire
  parsedSentiment   String?   // Positive/negative/neutral
  extractedEntities Json?     // Full GPT-4 extraction results
  
  // Geographic data (if location detected)
  latitude          Float?
  longitude         Float?
  address           String?
  city              String?
  state             String?
  geohash           String?
  
  // Processing status
  isProcessed       Boolean   @default(false)
  processingError   String?
  
  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relationships
  wonder            Wonder    @relation(fields: [wonderId], references: [id], onDelete: Cascade)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([wonderId, userId]) // One response per user per wonder
  @@index([wonderId, createdAt])
  @@index([userId, createdAt])
  @@index([parsedLocation])
  @@index([geohash])
  @@index([isProcessed])
  @@index([createdAt])
  @@map("wonder_responses")
}

model WonderPattern {
  id                    String           @id @default(cuid())
  wonderId              String
  
  // Pattern identification
  pattern               String           // e.g., "coffee shop need"
  confidence            Float            // 0.0 to 1.0
  supportCount          Int              @default(0)
  
  // Geographic clustering
  locationCluster       String?          // Identified area/neighborhood
  centerLatitude        Float?
  centerLongitude       Float?
  radius                Float?           // In meters
  
  // Auto-campaign generation
  suggestedCampaignTitle String?
  campaignId            String?          // If auto-generated campaign
  
  // Pattern evolution
  status                PatternStatus    @default(EMERGING)
  threshold             Int              @default(10) // Responses needed for action
  
  // Metadata
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  
  // Relationships
  wonder                Wonder           @relation(fields: [wonderId], references: [id], onDelete: Cascade)
  campaign              Campaign?        @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  
  @@index([wonderId, confidence])
  @@index([status, supportCount])
  @@index([locationCluster])
  @@index([createdAt])
  @@map("wonder_patterns")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model spatial_ref_sys {
  srid      Int     @id
  auth_name String? @db.VarChar(256)
  auth_srid Int?
  srtext    String? @db.VarChar(2048)
  proj4text String? @db.VarChar(2048)
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

enum VoteType {
  SUPPORT
  OPPOSE
}

enum DistrictType {
  CONGRESSIONAL
  STATE_SENATE
  STATE_HOUSE
  COUNTY
  CITY
  SCHOOL
}

enum WonderCategory {
  GENERAL
  BUSINESS
  RECREATION
  INFRASTRUCTURE
  COMMUNITY
  ENVIRONMENT
}

enum WonderTimeContext {
  MORNING
  LUNCH
  EVENING
  WEEKEND
  ANYTIME
}

enum WonderStatus {
  ACTIVE
  ARCHIVED
  CONVERTED_TO_CAMPAIGN
}

enum PatternStatus {
  EMERGING
  STRONG
  ACTIONABLE
  CONVERTED
}
